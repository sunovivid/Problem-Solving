코드가 작동을 안해
    미완성 스켈레톤 코드 실행했는데 의도대로 작동 안하면
        입출력 문제
            입력받은 문자열의 문자 하나씩 수행하는 도중 한번 더 수행됨
                for (int i=0;str[i]!='\0';i++)에서 '\0' 대신 '\n' 사용함: 자구과제4
            모든 데이터 입력 받았나 확인
                input stream 다 안 읽은 경우 - cin때문에 프로그램 안끝남
                input stream 이 남는 경우 - 남는 라인 입력 중간중간에 출력이 나옴
                :1967 트리의 지름 (n-1개만 읽어야 하는데 n개 입력)

    코드를 실행했는데 입력받고 아무것도 안하면
        우분투로 실행해 보기
            아무 것도 안뜨고 종료되면
                N을 입력받지 않음..
                    :10989 수 정렬하기 3

    코드를 실행하면 런타임 에러가 나오면(우분투) or 아무것도 안했는데 run하자마자 '작동이 중지되었습니다' 나오면
        우분투로 실행해 보기
            Segmentation fault 나오면
                SegFault 나올 수 있는 곳 찾기
                    case
                        fill:
                    case
                        배열 선언 (배열을 너무 크게 잡은 경우): 4179 불 (1000*1000 3개), 8112 0과 1 - 2 (1000010개 pair<int,bool>에 bool 추가할때)
                            선언만 하고 사용하지 않으면 컴파일러가 알아서 최적화해서 공간 할당 안하는듯
                            사용하는 순간 에러가 난다.
                    case
                        붙어 있는 배열 입력받기 위해 char* 사용
                        :1915 가장 큰 정사각형 (
                            char* temp;
                            for (int i=0;i<n;i++)
                                cin >> temp;
                                for (int j=0;j<m;j++)
                                    dp[i][j] = temp[j] - '0';
                            char*을 string으로 바꾸면 해결)
                else
                    주석처리 이분탐색

            Floating point exception (core dumped) 나오면
                n을 입력받지 않아 생긴 에러
                    :
            terminate called after throwing an instance of 'std::length_error'
                what():  vector::_M_default_append
                Aborted (core dumped)

            (int)''사용할 곳에 "" 사용
                :1726 로봇 (dx dy 식)

            반복문 내부에서 계속 갱신되는 값 반복문 조건으로 사용
                :10711 모래성 (for (int i=0; i<q.size();i++)으로 써서 반복문 안에서 계속 push해서 결과 이상해짐. 변수로 qsize기록하고 시작)

    테스트 케이스에서 답이 원하는 대로 안 나오면
        제일 기본적인 테스트 케이스부터 수행
            문제 조건 읽기
                :5427 불 (w h 순서 바꿔서 입력받음)
        제대로 나오면
            케이스 사이즈를 키워가며 수행
        이상한 점이 발견되면
            코드 읽어보기
                배열 사이즈
                int overflow -> 중간연산에서 가능성있으므로 전부 long long으로
                    :코포edu86 A
                코드 흐름 제어
                    continue(해당반복중단) < break(반복문중단) < return (함수중단)
                    while n-- 이후 n 사용
                    오른쪽부터 볼 때는 for문 안을 뒤바꿔야
                        :1932 정수 삼각형 (for 문 안 if로 케이스 분류 순서만 바꿈. 의미x)
                반복 문제 (dfs) -> 시작, 끝, 반복 단위 명확히 설정
                    :9663 N퀸(dfs종료조건 1작게설정), 8112 0과 1 - 2 (bfs 확장 전 goal test해서 처리 단계(부모배열에 기록) 수행 안됨)
                인덱스 문제
                    :1726 로봇 (좌상단이 1,1인데 0,0으로 가정함, 인덱스 = 패딩+1이어야)
                일부 초깃값 잘못 설정 (특히 DP, 초깃값 많을 때)
                    :9465 스티커 (초기 DP값 dp[0] = arr[1][0] + arr[0][1], dp[1] = arr[1][1] + arr[0][0]의 뒷부분을 교차한답시고 arr[0][1] + arr[1][0]으로 씀. 약속대로 쓰기)

            코드에 문제가 없는 것 같으면
                문제 정의 다시 읽어보기
                    :9663 N퀸(대각선 체크 x), 1726 로봇 (문제에서 보드 좌상단이 1,1이고 오른쪽 아래로 증가한다고 정의함)  

    테스트 케이스에서는 답이 나오는데 제출시 WA가 뜨면
        기본적인 엣지 케이스
            모든 부등호 확인
                문제조건: < 여야 하는지 <= 여야 하는지
                구현: <로 구현했는지 <= 로 구현했는지
                    :7568 덩치 (두 가지 기준으로 정렬하면 =도 포함됨), 14889 스타트와 링크 
            새로 조건을 만족하는 경우가 생기는 경우
                :1068 트리 (자식이 1개인 노드의 경우 그 자식 삭제하면 리프 노드가 됨)
        정확한 알고리즘 구현 실패 - 처음부터 잘못 짠경우 (일부 케이스만을 대상으로 코드 작성한 경우)
            알고리즘 타당성 증명
                모든 과정 후 조건 만족하는 것 구하는 게 아니라 각 과정의 변화를 누적하는 방식으로 구한 경우
                    예상치 못한 경우가 등장할 수 있다
                        :1068 트리 (변화 후 리프 노드 수를 (처음 리프 노드 수) - (삭제된 리프 노드 수)로 구했는데 새로 생성되는 리프 노드가 존재한다!)

        case
            0%:
                최소 사이즈 엣지 케이스
                    :1068 트리 (리프 노드 개수 구하기에서 루트를 제거하는 경우)
                
                or

                ***잘못된 로직 구현 (일반화 케이스)
                    잘못된 로직 구현 WA뜨는 케이스 만들기
                        역순으로 넣어보기 (습관적으로 정렬된 데이터를 넣는 경우가 많음)
                            :1967 트리의 지름 (secondLargest 구하는 방법 틀림, 역순 입력하면 발견)
                        개수 늘리기
                            :1967 트리의 지름 (자식 2개가 기본값, 자식 개수 3개 이상으로)
                        DP 전이 케이스 모두 확인
                            :2156 포도주 시식 (계단 문제와 달리 전이 제약이 없어 한번에 3계단 점프할 때도 있음)
                        정렬시 같은 것이 존재할 경우
                            :ALPS 2020 여름 D (두 가지 기준으로 정렬하는데 같은 가격이 존재할 경우 처리)
                    :secondLargest 갱신 로직에서는 Largest 갱신할때 secondLargest도 같이 갱신해야!
                        :1967 트리의 지름
                    

                오버플로우
                    long long int 사용
                        :2156 포도주 시식
                    배열의 크기와 배열이 타입 크기를 구분하자
                        : ALPS 2020 여름C (DP 배열 사이즈는 문제의 N 범위, DP 배열 타입은 약속한 나머지 R이 담기는 크기로)
            0~5%:
                기본적인 엣지 케이스
                    모든 부등호 확인
                        :7568 덩치 (두 가지 기준으로 정렬하면 =도 포함됨), 14889 스타트와 링크 
                    여러 개 비교하는 상황에서 1개인 경우, 0개인 경우
                        :1967 트리의 지름 (여러 자식 중 가장 큰 것 + 두 번째로 큰 것으로 노드 값 계산할때 자식이 하나인 경우 처리방법)
                나눗셈이 존재할 경우
                    어떻게 처리하라고 했는지 문제조건 확인
                        :10989 수 정렬하기 (산술평균을 소수 첫번째 자리에서 반올림하라고 함)
                케이스 분류하고 케이스마다 해야하는 작업 안해준 경우
                    :코드포스 A and B and Compilation Errors (예외 케이스에서 출력에 '\n' 안붙임)
            5~99%:
                문제 조건 확인
                    :4179 불! (불이 여러 개일 수 있는데 하나로 가정함)
                인덱스 통일 - 0~n-1 인덱스인지 1~n 인덱스인지 통일. 
                    특히 배열의 [i]에서 i가 0부터 시작해서 n-1에서 끝나는지 확인
                    문제에서 1로 시작하는 번호가 주어진 경우 주의
                    :14889 스타트와 링크 (59% - 배열 인덱스를 1234로 그려둬서 1234 사용)
                pruning 코드 없애보기 - 정답까지 가지치기하는지
                    :14889 스타트와 링크 (59% - 대칭적인 결과 0과 양수만 봄), 1068 트리 (78%) ??
                for i = i to n 과 vector push_back 혼용
                    resize(n)
                        for i = 1 to n {vec[i] 대입} //push_back 하면 의도와 다르게 작동
                        or
                        for &elem : vec {elem 대입}
                    reserve(n), for i = 1 to n {vec.push_back} //vec[i] 불가
                    :1068 트리 (79% - resize(n)으로 채우고 for (i=1 to n) 안에서 push_back해서 n+1칸부터 쌓임)
                변수 초기값이 모든 케이스 커버하나 확인 -> 초기값의 갱신이 안 되는 경우에도 초기값이 모든 케이스 커버하나? (특히 DP)
                    :1915 가장 큰 정사각형 (max_size 0으로 초기화했는데 DP 갱신을 1번 라인부터 해서, 0번 라인에서 최대 사이즈가 존재하는 경우에도 max_size 갱신 안하고 0으로 나오는 케이스 존재)

    제출시 런타임 에러가 뜨면
        배열에 할당된 크기를 넘어서 접근했을 때
            :입력 개수보다 배열을 적게 할당했을 때
                :8112 0과 1 - 2
        전역 배열의 크기가 메모리 제한을 초과할 때
        지역 배열의 크기가 스택 크기 제한을 넘어갈 때
        0으로 나눌 떄
        라이브러리에서 예외를 발생시켰을 때
        재귀 호출이 너무 깊어질 때
        이미 해제된 메모리를 또 참조할 때
        프로그램(main 함수)이 0이 아닌 수를 반환했을 때, 반환형이 void가 아닌 main이 아닌 함수에서 아무런 값을 반환하지 않았을 때

코드를 깔끔하게 짜기
    에러를 줄이는 코딩
    min, max구할 때 INF 할당
        양수 범위라고 -1 넣을 게 아니라 -987654321같은 극단적인 값 넣어야 출력 보고 이상한 점 발견함
        INT8_MAX는 127임에 주의
    기본값으로부터 반드시 변해야 하는 값은 변했는지 assert()로 확인하기
        ex) MAX: default -INF 아님을 확인
    나누기 처리(평균, 분산, ...)
        곱해서 계산
        최솟값 구해야 하는 거면 가까운 정수 둘 다 해보기

    코드를 명료하게 만들기
        간단한 구현 팁
            역순 정렬하기
                재귀 함수 사용하고 재귀 후 처리 (사실상 스택에 넣고 꺼내기)
        예외 처리 줄이는 방법
            정보를 좀 더 많이 담기
                dp차원 확장
                    :1149 RGB 거리, dp에 color 차원을 추가하니 훨씬 명료하고 같은 cost존재하는 예외 처리 필요없는 코드 만들 수 있었음

기억할 만한 사항
    수학
        나머지
            def. n % x = b <=> n = ax + b
            성질
                (a + m) % m = a % m
                (a + b) % m = (a % m + b % m) % m
                (a * b) % m = (a % m * b % m) % m
            노드에 나머지 저장하기
                허용되는 상황: linear 연산? (ax + by + c)
                    pf)
                        x, y => ax + by + c
                        x % m, y % m => a(x % m) + b(y % m) + c
                        todo: (ax + by + c)%m = a(x % m) + b(y % m) + c 증명
                            (ax + by + c)%m = ((ax) % m + (by) % m + c % m) % m
                            = ((a % m) * (x % m) % m + (b % m) * (y % m) % m + c % m) % m
                            (a, b, c < m 이면)
                            = (a * (x % m) % m + b * (y % m) % m + c % m) % m
                            = (a * (x % m) + b * (y % m) + c) % m
    C++
        2차원 배열의 작동원리 #
            메모리 주소는 어차피 1차원이라 arr[행][열] = arr + 행 * 열갯수 + 열 로 계산하는듯
            그러니까 함수에 n차원 배열 넘겨줄 때는 첫 인자는 비워도 되고 나머지는 채워야 하는 것
            (행 갯수는 몰라도 각 칸의 주소를 계산할 수 있지만, 열 갯수는 모르면 주소 계산 못하므로)
            ex) arr[][] = {1,2,3,4,5,6,7,8,9} 컴퓨터: ??
                arr[][3] = {1,2,3,4,5,6,7,8,9} 컴퓨터: 아하! 3마다 다음 행으로 보는군

        2차원 배열의 초기화
            memset: 사용법 간단, 0/-1/1로만 초기화 가능?
            fill: char 2차원 배열 초기화할 때 뭔가 문제가 있었다..? (4179불)
            안되면 그냥 2중for문써라

        항상 헷갈리는 compare
            sort의 인자로 쓰이는 bool compare (a, b) return predicate(a,b)
            앞의 원소 a, 뒤의 원소 b가 predicate(a, b)를 만족하도록 정렬함 (예: return a < b: 앞의 원소 a < 뒤의 원소 b를 만족하도록 정렬함)

        벡터의 활용
            선언
                vector initilize with size n: vector<type> vec(n)
                    벡터의 재할당 연산 시간소요를 막으려면 처음부터 reserve()를 이용해 capacity를 늘려둬라.
                = vector 선언 + vector resize()
                    resize (기본값으로 초기화된 원소 삽입(size변함)) != reserve (공간 예약(capacity 변함, size 변하지 않음), 메모리 공간 할당만 하고 컨테이너 추가하지 않아 push_back안하고 [index]로 사용 불가)
                벡터를 선언하는 5가지 방법 https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/
                특정 size의 벡터를 생성하는 방법 https://stackoverflow.com/questions/25108854/initializing-the-size-of-a-c-vector/25108894 
                전역 벡터 size n 선언
                    vector <type> vec;
                    int main() {
                        vec = vector<type>(n);
                    }
            입력
                vector input: for (auto &elem: vec) {cin >> elem}
            정렬
                vector sort with lamda: [](type a, type b){return a < b;}
            기타 기능
                vector make vecotr unique: unique(vec.begin(), vec.end()) => 중복된 원소 뒤로 보내버려 생긴 쓰레기값의 시작점 리턴
                                    erase(unique(vec.begin(), vec.end()) , vec.end());
            
        입출력
            문자열 다루어야 하면 string 이용
                int를 포함한 문자열 출력해야 하면 to_string(int n) 이용
                concatenating: 문자열끼리는 그냥 + 연산자 가능
                slicing: output = output.substr(k, output.length() - n); 앞 k, 뒤 n 글자 잘라내기 (대입해줘야 하는 거 보니 imutable 속성인듯)
                'cout << string변수'로 쉽게 출력 가능

        내장함수
            min: 3개 이상 인자 비교할땐 min({elem1, elem2, elem3}) 중괄호로 감싸기

문제풀이 방법론
    방법론
    문제유형: CSP? Optimization? Search? Regression?
        Regression 문제: 결과가 equivalent한 더 빠른 규칙 찾기
        step 1. 완전탐색하는 방법 생각 (정의역에서 원소 차례로 / DFS / BFS, ...)
        step 2. 관계성 찾기: 수학적 귀납법 (최소한의 정보만 체크, 중복된 정보 제거, )
            있으면? => 활용
                직접적인 관계 => 그리디
                점화식 => DP
                부분 구조 반복 => 분할 정복, DP
            없으면? => NP문제 (완전탐색, DFS, BFS)

    알고리즘
        완전탐색
            반복문구현
            재귀구현
                1. 그림그리기 (구조화) - 상향식/하향식 결정
                2. 목적을 명확히 - 함수의 인자와 return값 결정
                3. base condition 설정
                4. 작업 명확히 하기
        그래프 탐색
            탐색!
                문제 형식화
                    초기상태, 액션, 전이모형, 골 테스트, 경로비용 
            그래프의 표현
                인접 행렬: 2차원 배열 - 메모리 사용 많음
                인접 리스트: 벡터 - 메모리 사용 적음
            DFS: 다음 자식을 탐색하기 전에 그전 자식의 모든 subgraph탐색
                재귀구현
                {type} dfs(int cur) {
                    visit[cur] = 1;
                    for i in adj[cur] {
                        if (visit[adj[cur][i]]) //base condition
                            continue;
                        dfs(adj[cur][i]);
                    }
                    visit[cur] = 0;
                }
                스택구현
            BFS
                템플릿
                    while q not empty
                        방문 (pop)
                        자식 생성
                        for 자식들에 대해
                            (생성 가능한 노드인가 테스트)
                            visited 테스트
                            골 테스트

                            visited 플래그
                            노드 처리
                            확장 (push)
                
                주의사항
                    goal test 순서가 답에 영향을 줄 수 있다 (부모를 확인해야 하는데 덮어씌우는 경우)
                        방문, 처리, test 순서를 일관되게! 방문->처리->테스트 or 방문->테스트->처리 (특히 goal test와 visit test는 같은 수준에서 수행해야)
                            :8112 0과 1 - 2 (goal,visit 테스트 같은 수준에서 안함)
                    visited는 상태 공간과 같은 차원
                        :1726 로봇 (visited를 map처럼 2차원으로 했는데 방향을 포함한 3차원이어야 함)
                BFS에 레벨을 추가하는 법
                    1. 레벨 기록
                        배열에, 혹은 상태노드에 레벨을 기록하고 자식들은 +1에서 확장
                        각 레벨을 순차적으로 펼치게 됨
                    2. 레벨 단위 수행
                        큐가 빌때까지 계속 반복하는 게 아니라 각 단위에서 큐 사이즈만큼 반복
                        단위가 상태 노드 단위가 아니라 레벨 단위로 반복하게 됨
        DP
            문제풀이 순서
                step1. DP 설정하기 (목표를 고려해서 명료하게)
                    DP 테이블이 모든 케이스 커버하도록 해야 한다.
                    방법1 목표 = DP 테이블
                        DP에서 목표 도출은 쉬우나 DP 점화식 찾기가 어려울 수 있다
                    방법2 목표 != DP 테이블
                        점화식 찾기가 쉬워지나 DP 테이블과 정답과의 관계를 추가로 설정해야 한다
                            :1915 가장 큰 정사각형 (모든 DP 테이블 계산할때 max값 갱신한 것이 정답)
                step2. 점화식 도출하기
                    easy
                        해당 DP로 오는 모든 케이스 고려하기
                            다른 케이스에 포함되는 케이스는 제외하기
                        계단 그림으로 생각
                            한 계단 아래, 두 계단 아래.. 모두 고려하기 (모든 케이스 커버)
                            계단을 내려가다 보면 특정 순간부터 모두 다른 케이스에 포함됨 (불필요한 경우 제외)
                    HARD
                        '전체가 최적이면 부분도 최적' 구조를 가질 때
                            하향식으로 겹치는 부분, 빠지는 부분 없이 완전히 케이스 분할
                            각 케이스는 부분 최적 구조를 포함해야 함.
                            tip - DP를 '남은 돈' 따위가 아니라 '사용가능한 돈'의 뉘앙스로 정의
                                :knapsack problem (i번째 아이템을 산 경우(가능할 때)와 사지 않은 경우로 분할해 최댓값 구하기)
            구성요건
                초기조건
                점화식 (iterative consistency)
                    상향식
                    하향식
                        해당 DP로 오는 모든 케이스 커버하면 OK
                끝 (iterative consistency를 활용해 답 도출)
            최적화: 전체 DP 테이블 유지할 필요 없을 때 많다.
                갱신에 필요한 DP 값만 유지! (변수 혹은 배열 일부)
                    단, 공간은 절약하는 대신 이전 dp 갱신 비용 듦.
                    dp, dp_prev, dp_prev_prev: dp[i] = f(dp[i-1], dp[i-2])
                    dp[n], dp_prev[n] : 2차원 혹은 구간(라인)별로
                => 큐 사용하면 갱신비용도 필요없다?
                갱신에 필요한 인덱스를 보고 순서를 잘 맞추면 이전 DP값 저장할 필요 없을때도 있다
                    cf) dp갱신 순서가 뒤섞이면 (화살표가 교점이 생기면) dp갱신에 이미 갱신된 dp 사용됨 => 이전 dp 저장 필요
                    : 1932 정수 삼각형 (갱신시 i, i-1만 보므로 오른쪽부터 갱신하면 dp_prev를 저장할 필요 없음)