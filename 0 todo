미완성 스켈레톤 코드 실행했는데 의도대로 작동 안하면
    입출력 문제
        입력받은 문자열의 문자 하나씩 수행하는 도중 한번 더 수행됨
            for (int i=0;str[i]!='\0';i++)에서 '\0' 대신 '\n' 사용함: 자구과제4
        모든 데이터 입력 받았나 확인
            input stream 다 안 읽은 경우 - cin때문에 프로그램 안끝남
            input stream 이 남는 경우 - 남는 라인 입력 중간중간에 출력이 나옴
            :1967 트리의 지름 (n-1개만 읽어야 하는데 n개 입력)

코드를 실행했는데 입력받고 아무것도 안하면
    우분투로 실행해 보기
        아무 것도 안뜨고 종료되면
            N을 입력받지 않음..
                :10989 수 정렬하기 3

코드를 실행하면 런타임 에러가 나오면(우분투) or 아무것도 안했는데 run하자마자 '작동이 중지되었습니다' 나오면
    우분투로 실행해 보기
        Segmentation fault 나오면
            SegFault 나올 수 있는 곳 찾기
            case
                fill:
            case
                배열 선언 (배열을 너무 크게 잡은 경우): 4179 불 (1000*1000 3개), 8112 0과 1 - 2 (1000010개 pair<int,bool>에 bool 추가할때)
                    선언만 하고 사용하지 않으면 컴파일러가 알아서 최적화해서 공간 할당 안하는듯
                    사용하는 순간 에러가 난다.
            else
                주석처리 이분탐색

        Floating point exception (core dumped) 나오면
            n을 입력받지 않아 생긴 에러
                :
        terminate called after throwing an instance of 'std::length_error'
            what():  vector::_M_default_append
            Aborted (core dumped)

        (int)''사용할 곳에 "" 사용
            :1726 로봇 (dx dy 식)

테스트 케이스에서 답이 원하는 대로 안 나오면
    제일 기본적인 테스트 케이스부터 수행
        문제 조건 읽기
            :5427 불 (w h 순서 바꿔서 입력받음)
    제대로 나오면
        케이스 사이즈를 키워가며 수행
    이상한 점이 발견되면
        코드 읽어보기
            배열 사이즈
            int overflow -> 중간연산에서 가능성있으므로 전부 long long으로
                :코포edu86 A
            코드 흐름 제어 (continue(해당반복중단) < break(반복문중단) < return (함수중단))
            반복 문제 (dfs) -> 시작, 끝, 반복 단위 명확히 설정
                :9663 N퀸(dfs종료조건 1작게설정), 8112 0과 1 - 2 (bfs 확장 전 goal test해서 처리 단계(부모배열에 기록) 수행 안됨)
            인덱스 문제
                :1726 로봇 (좌상단이 1,1인데 0,0으로 가정함, 인덱스 = 패딩+1이어야)
        코드에 문제가 없는 것 같으면
            문제 정의 다시 읽어보기
                :9663 N퀸(대각선 체크 x), 1726 로봇 (문제에서 보드 좌상단이 1,1이고 오른쪽 아래로 증가한다고 정의함)  

테스트 케이스에서는 답이 나오는데 제출시 WA가 뜨면
    기본적인 엣지 케이스
        모든 부등호 확인
            문제조건: < 여야 하는지 <= 여야 하는지
            구현: <로 구현했는지 <= 로 구현했는지
                :7568 덩치 (두 가지 기준으로 정렬하면 =도 포함됨), 14889 스타트와 링크 
        새로 조건을 만족하는 경우가 생기는 경우
            :1068 트리 (자식이 1개인 노드의 경우 그 자식 삭제하면 리프 노드가 됨)
    정확한 알고리즘 구현 실패 - 처음부터 잘못 짠경우 (일부 케이스만을 대상으로 코드 작성한 경우)
        알고리즘 타당성 증명
            모든 과정 후 조건 만족하는 것 구하는 게 아니라 각 과정의 변화를 누적하는 방식으로 구한 경우
                예상치 못한 경우가 등장할 수 있다
                    :1068 트리 (변화 후 리프 노드 수를 (처음 리프 노드 수) - (삭제된 리프 노드 수)로 구했는데 새로 생성되는 리프 노드가 존재한다!)

    case
        0%:
            최소 사이즈 엣지 케이스
                :1068 트리 (리프 노드 개수 구하기에서 루트를 제거하는 경우)
            
            or

            잘못된 로직 구현 (일반화 케이스)
                잘못된 로직 구현 WA뜨는 케이스 만들기
                    역순으로 넣어보기 (습관적으로 정렬된 데이터를 넣는 경우가 많음)
                        :1967 트리의 지름 (secondLargest 구하는 방법 틀림, 역순 입력하면 발견)
                    개수 늘리기
                        :1967 트리의 지름 (자식 2개가 기본값, 자식 개수 3개 이상으로)
                :secondLargest 갱신 로직에서는 Largest 갱신할때 secondLargest도 같이 갱신해야!
                    :1967 트리의 지름
        0~5%:
            기본적인 엣지 케이스
                모든 부등호 확인
                    :7568 덩치 (두 가지 기준으로 정렬하면 =도 포함됨), 14889 스타트와 링크 
                여러 개 비교하는 상황에서 1개인 경우, 0개인 경우
                    :1967 트리의 지름 (여러 자식 중 가장 큰 것 + 두 번째로 큰 것으로 노드 값 계산할때 자식이 하나인 경우 처리방법)
            나눗셈이 존재할 경우
                어떻게 처리하라고 했는지 문제조건 확인
                    :10989 수 정렬하기 (산술평균을 소수 첫번째 자리에서 반올림하라고 함)
            케이스 분류하고 케이스마다 해야하는 작업 안해준 경우
                :코드포스 A and B and Compilation Errors (예외 케이스에서 출력에 '\n' 안붙임)
        5~99%:
            문제 조건 확인
                :4179 불! (불이 여러 개일 수 있는데 하나로 가정함)
            인덱스 통일 - 0~n-1 인덱스인지 1~n 인덱스인지 통일. 
                특히 배열의 [i]에서 i가 0부터 시작해서 n-1에서 끝나는지 확인
                문제에서 1로 시작하는 번호가 주어진 경우 주의
                :14889 스타트와 링크 (59% - 배열 인덱스를 1234로 그려둬서 1234 사용)
            pruning 코드 없애보기 - 정답까지 가지치기하는지
                :14889 스타트와 링크 (59% - 대칭적인 결과 0과 양수만 봄), 1068 트리 (78%) ??
            for i = i to n 과 vector push_back 혼용
                resize(n)
                    for i = 1 to n {vec[i] 대입} //push_back 하면 의도와 다르게 작동
                    or
                    for &elem : vec {elem 대입}
                reserve(n), for i = 1 to n {vec.push_back} //vec[i] 불가
                :1068 트리 (79% - resize(n)으로 채우고 for (i=1 to n) 안에서 push_back해서 n+1칸부터 쌓임)

제출시 런타임 에러가 뜨면
    배열에 할당된 크기를 넘어서 접근했을 때
        :입력 개수보다 배열을 적게 할당했을 때
            :8112 0과 1 - 2
    전역 배열의 크기가 메모리 제한을 초과할 때
    지역 배열의 크기가 스택 크기 제한을 넘어갈 때
    0으로 나눌 떄
    라이브러리에서 예외를 발생시켰을 때
    재귀 호출이 너무 깊어질 때
    이미 해제된 메모리를 또 참조할 때
    프로그램(main 함수)이 0이 아닌 수를 반환했을 때, 반환형이 void가 아닌 main이 아닌 함수에서 아무런 값을 반환하지 않았을 때

에러를 줄이는 코딩
    min, max구할 때 INF 할당
        양수 범위라고 -1 넣을 게 아니라 -987654321같은 극단적인 값 넣어야 출력 보고 이상한 점 발견함
        INT8_MAX는 127임에 주의
    기본값으로부터 반드시 변해야 하는 값은 변했는지 assert()로 확인하기
        ex) MAX: default -INF 아님을 확인

코드를 명료하게 만들기
    간단한 구현 팁
        역순 정렬하기
            재귀 함수 사용하고 재귀 후 처리 (사실상 스택에 넣고 꺼내기)
    예외 처리 줄이는 방법
        정보를 좀 더 많이 담기
            dp차원 확장
                :1149 RGB 거리, dp에 color 차원을 추가하니 훨씬 명료하고 같은 cost존재하는 예외 처리 필요없는 코드 만들 수 있었음

기억할 만한 사항
    수학
        나머지 정리
            def. n % x = b <=> n = ax + b
            성질
                (a + m) % m = a % m
                (a + b) % m = (a % m + b % m) % m
                (a * b) % m = (a % m * b % m) % m
    C++
        2차원 배열의 작동원리 #
            메모리 주소는 어차피 1차원이라 arr[행][열] = arr + 행 * 열갯수 + 열 로 계산하는듯
            그러니까 함수에 n차원 배열 넘겨줄 때는 첫 인자는 비워도 되고 나머지는 채워야 하는 것
            (행 갯수는 몰라도 각 칸의 주소를 계산할 수 있지만, 열 갯수는 모르면 주소 계산 못하므로)
            ex) arr[][] = {1,2,3,4,5,6,7,8,9} 컴퓨터: ??
                arr[][3] = {1,2,3,4,5,6,7,8,9} 컴퓨터: 아하! 3마다 다음 행으로 보는군

        2차원 배열의 초기화
            memset: 사용법 간단, 0/-1/1로만 초기화 가능?
            fill: char 2차원 배열 초기화할 때 뭔가 문제가 있었다..? (4179불)
            안되면 그냥 2중for문써라

        항상 헷갈리는 compare
            sort의 인자로 쓰이는 bool compare (a, b) return predicate(a,b)
            앞의 원소 a, 뒤의 원소 b가 predicate(a, b)를 만족하도록 정렬함 (예: return a < b: 앞의 원소 a < 뒤의 원소 b를 만족하도록 정렬함)

        벡터의 활용
            선언
                vector initilize with size n: vector<type> vec(n)
                    벡터의 재할당 연산 시간소요를 막으려면 처음부터 reserve()를 이용해 capacity를 늘려둬라.
                = vector 선언 + vector resize()
                    resize (기본값으로 초기화된 원소 삽입(size변함)) != reserve (공간 예약(capacity 변함, size 변하지 않음), 메모리 공간 할당만 하고 컨테이너 추가하지 않아 push_back안하고 [index]로 사용 불가)
                벡터를 선언하는 5가지 방법 https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/
                특정 size의 벡터를 생성하는 방법 https://stackoverflow.com/questions/25108854/initializing-the-size-of-a-c-vector/25108894 
                전역 벡터 size n 선언
                    vector <type> vec;
                    int main() {
                        vec = vector<type>(n);
                    }
            입력
                vector input: for (auto &elem: vec) {cin >> elem}
            정렬
                vector sort with lamda: [](type a, type b){return a < b;}
            기타 기능
                vector make vecotr unique: unique(vec.begin(), vec.end()) => 중복된 원소 뒤로 보내버려 생긴 쓰레기값의 시작점 리턴
                                    erase(unique(vec.begin(), vec.end()) , vec.end());
            
        입출력
            문자열 다루어야 하면 string 이용
                int를 포함한 문자열 출력해야 하면 to_string(int n) 이용
                concatenating: 문자열끼리는 그냥 + 연산자 가능
                slicing: output = output.substr(k, output.length() - n); 앞 k, 뒤 n 글자 잘라내기 (대입해줘야 하는 거 보니 imutable 속성인듯)
                'cout << string변수'로 쉽게 출력 가능

        내장함수
            min: 3개 이상 인자 비교할땐 min({elem1, elem2, elem3}) 중괄호로 감싸기

//외판원순회2 상향식?
//while n-- 이후 n 사용
//secondLargest max 혼용

방법론
완전탐색하는 방법 생각 (정의역에서 원소 차례로 / DFS / BFS, ...)
그리디 시도! -> 수학적 귀납법 찾기 -> 없으면 NP문제 (완전탐색)

완전탐색
    반복문구현
    재귀구현
        1. 그림그리기 (구조화) - 상향식/하향식 결정
        2. 목적을 명확히 - 함수의 인자와 return값 결정
        3. base condition 설정
        4. 작업 명확히 하기
그래프 탐색
    탐색!
        문제 형식화
            초기상태, 액션, 전이모형, 골 테스트, 경로비용 
    그래프의 표현
        인접 행렬: 2차원 배열 - 메모리 사용 많음
        인접 리스트: 벡터 - 메모리 사용 적음
    DFS: 다음 자식을 탐색하기 전에 그전 자식의 모든 subgraph탐색
        재귀구현
        {type} dfs(int cur) {
            visit[cur] = 1;
            for i in adj[cur] {
                if (visit[adj[cur][i]]) //base condition
                    continue;
                dfs(adj[cur][i]);
            }
            visit[cur] = 0;
        }
        스택구현
    BFS
        템플릿
            while q not empty
                방문 (pop)
                자식 생성
                for 자식들에 대해
                    (생성 가능한 노드인가 테스트)
                    visited 테스트
                    골 테스트

                    visited 플래그
                    노드 처리
                    확장 (push)
        
        주의사항
            goal test 순서가 답에 영향을 줄 수 있다 (부모를 확인해야 하는데 덮어씌우는 경우)
                방문, 처리, test 순서를 일관되게! 방문->처리->테스트 or 방문->테스트->처리 (특히 goal test와 visit test는 같은 수준에서 수행해야)
                    :8112 0과 1 - 2 (goal,visit 테스트 같은 수준에서 안함)
            visited는 상태 공간과 같은 차원
                :1726 로봇 (visited를 map처럼 2차원으로 했는데 방향을 포함한 3차원이어야 함)
        BFS에 레벨을 추가하는 법
            1. 레벨 기록
                배열에, 혹은 상태노드에 레벨을 기록하고 자식들은 +1에서 확장
                각 레벨을 순차적으로 펼치게 됨
            2. 레벨 단위 수행
                큐가 빌때까지 계속 반복하는 게 아니라 각 단위에서 큐 사이즈만큼 반복
                단위가 상태 노드 단위가 아니라 레벨 단위로 반복하게 됨
DP
    