코드가 작동을 안해
    코드가 실행이 안되면
        참조형 반복자 전달 문제
            stirng::iterator it = str.begin()으로 타입을 직접 선언해 주자.
            :알고스팟 quadtree (함수에서 인자로 string::iterator 받았는데 바로 str.begin()으로 전달하니 에러남)

    미완성 스켈레톤 코드 실행했는데 의도대로 작동 안하면
        입출력 문제
            입력받은 문자열의 문자 하나씩 수행하는 도중 한번 더 수행됨
                for (int i=0;str[i]!='\0';i++)에서 '\0' 대신 '\n' 사용함: 자구과제4
            모든 데이터 입력 받았나 확인
                input stream 다 안 읽은 경우 - cin때문에 프로그램 안끝남
                input stream 이 남는 경우 - 남는 라인 입력 중간중간에 출력이 나옴
                :1967 트리의 지름 (n-1개만 읽어야 하는데 n개 입력)
            2차원 문자열 배열 붙어있는채로 받을때도 cin 2중 for문 사용해야 됨
                왜 그런지는 모름
        #define 매크로 괄호 문제
            매크로 함수의 인자는 모두 괄호로 감싸는 것이 안전
                :2439 별 찍기 - 8 (#define abs(a) a >= 0 ? a : -(a)의 마지막 괄호를 -a로 표기해서 실제 코드 변환시 abs(x+y)하면 -(x+y)가 아니라 -x+y로 변환됨
        0 나옴 / 이상한 숫자나옴
            삼항 연산자 (?:)의 우선순위 문제 => 삼항 연산자는 항상 괄호로 묶는 게 안전
                :알고스팟 Quantize

    코드를 실행했는데 입력받고 아무것도 안하면
        우분투로 실행해 보기
            아무 것도 안뜨고 종료되면
                N을 입력받지 않음..
                    :10989 수 정렬하기 3

    코드를 실행하면 런타임 에러가 나오면(우분투) or 아무것도 안했는데 run하자마자 '작동이 중지되었습니다' 나오면
        우분투로 실행해 보기
            Segmentation fault 나오면
                SegFault 나올 수 있는 곳 찾기
                    case
                        fill:
                    case
                        배열 선언 (배열을 너무 크게 잡은 경우): 4179 불 (1000*1000 3개), 8112 0과 1 - 2 (1000010개 pair<int,bool>에 bool 추가할때)
                            선언만 하고 사용하지 않으면 컴파일러가 알아서 최적화해서 공간 할당 안하는듯
                            사용하는 순간 에러가 난다.
                    case
                        붙어 있는 배열 입력받기 위해 char* 사용
                        :1915 가장 큰 정사각형 (
                            char* temp;
                            for (int i=0;i<n;i++)
                                cin >> temp;
                                for (int j=0;j<m;j++)
                                    dp[i][j] = temp[j] - '0';
                            char*을 string으로 바꾸면 해결)
                else
                    주석처리 이분탐색

            Floating point exception (core dumped) 나오면
                n을 입력받지 않아 생긴 에러
                    :
            terminate called after throwing an instance of 'std::length_error'
                what():  vector::_M_default_append
                Aborted (core dumped)

            (int)''사용할 곳에 "" 사용
                :1726 로봇 (dx dy 식)

            반복문 내부에서 계속 갱신되는 값 반복문 조건으로 사용
                :10711 모래성 (for (int i=0; i<q.size();i++)으로 써서 반복문 안에서 계속 push해서 결과 이상해짐. 변수로 qsize기록하고 시작)

    테스트 케이스에서 답이 원하는 대로 안 나오면
        제일 기본적인 테스트 케이스부터 수행
            문제 조건, 정의 다시 읽어보기
                :5427 불 (w h 순서 바꿔서 입력받음), 9663 N퀸(대각선 체크 x), 1726 로봇 (문제에서 보드 좌상단이 1,1이고 오른쪽 아래로 증가한다고 정의함)
            코드 읽어보기
            
                입력을 잘못 받은 경우
                    입력 다시 출력해서 제대로 받았나 확인
                        :알고스팟 Quantize(vector.push_back(in)에서 in을 i로 잘못 씀)
                배열 사이즈
                int overflow -> 중간연산에서 가능성있으므로 전부 long long으로
                    :코포edu86 A

                코드 흐름 제어
                    continue(해당반복중단) < break(반복문중단) < return (함수중단)
                    while n-- 이후 n 사용
                    오른쪽부터 볼 때는 for문 안을 뒤바꿔야
                        :1932 정수 삼각형 (for 문 안 if로 케이스 분류 순서만 바꿈. 의미x)
                반복 문제 (dfs) -> 시작, 끝, 반복 단위 명확히 설정
                    :9663 N퀸(dfs종료조건 1작게설정), 8112 0과 1 - 2 (bfs 확장 전 goal test해서 처리 단계(부모배열에 기록) 수행 안됨)
                인덱스 문제
                    :1726 로봇 (좌상단이 1,1인데 0,0으로 가정함, 인덱스 = 패딩+1이어야)
                일부 초깃값 잘못 설정 (특히 DP, 초깃값 많을 때)
                    :9465 스티커 (초기 DP값 dp[0] = arr[1][0] + arr[0][1], dp[1] = arr[1][1] + arr[0][0]의 뒷부분을 교차한답시고 arr[0][1] + arr[1][0]으로 씀. 약속대로 쓰기)
                실수와 정수 문제
                    부분합 이용해 최소오차제곱의합 구할 때 정수만 가능하면 평균을 floor해야 함. 이때문에 sum != mean * numOfElement가 된다.
                        :알고스팟 Quantize

    테스트 케이스에서는 답이 나오는데 제출시 WA가 뜨면
        기본적인 엣지 케이스
            모든 부등호 확인
                문제조건: < 여야 하는지 <= 여야 하는지
                구현: <로 구현했는지 <= 로 구현했는지
                    :7568 덩치 (두 가지 기준으로 정렬하면 =도 포함됨), 14889 스타트와 링크 
            새로 조건을 만족하는 경우가 생기는 경우
                :1068 트리 (자식이 1개인 노드의 경우 그 자식 삭제하면 리프 노드가 됨)
        정확한 알고리즘 구현 실패 - 처음부터 잘못 짠경우 (일부 케이스만을 대상으로 코드 작성한 경우)
            알고리즘 타당성 증명
                모든 과정 후 조건 만족하는 것 구하는 게 아니라 각 과정의 변화를 누적하는 방식으로 구한 경우
                    예상치 못한 경우가 등장할 수 있다
                        :1068 트리 (변화 후 리프 노드 수를 (처음 리프 노드 수) - (삭제된 리프 노드 수)로 구했는데 새로 생성되는 리프 노드가 존재한다!)

        case
            0%:
                최소 사이즈 엣지 케이스
                    :1068 트리 (리프 노드 개수 구하기에서 루트를 제거하는 경우)
                
                or

                ***잘못된 로직 구현 (일반화 케이스)
                    WA뜨는 케이스 만들기
                        역순으로 넣어보기 (습관적으로 정렬된 데이터를 넣는 경우가 많음)
                            :1967 트리의 지름 (secondLargest 구하는 방법 틀림, 역순 입력하면 발견)
                        개수 늘리기
                            :1967 트리의 지름 (자식 2개가 기본값, 자식 개수 3개 이상으로)
                        DP 전이 케이스 모두 확인
                            :2156 포도주 시식 (계단 문제와 달리 전이 제약이 없어 한번에 3계단 점프할 때도 있음)
                        정렬시 같은 것이 존재할 경우
                            :ALPS 2020 여름 D (두 가지 기준으로 정렬하는데 같은 가격이 존재할 경우 처리)
                    :secondLargest 갱신 로직에서는 Largest 갱신할때 secondLargest도 같이 갱신해야!
                        :1967 트리의 지름
                    
                ***모든 케이스 커버하나 확인
                    a[-1] = -INF에서 시작하도록 하기
                        :11054 가장 긴 바이토닉 부분 수열 (모든 인덱스에서 시작하는 수열을 고려해야 하는데, 처음 인덱스에서 시작하는 수열만 고려함)

                ***오버플로우
                    long long int 사용
                        :2156 포도주 시식
                    배열의 크기와 배열이 타입 크기를 구분하자
                        : ALPS 2020 여름C (DP 배열 사이즈는 문제의 N 범위, DP 배열 타입은 약속한 나머지 R이 담기는 크기로)
                    나머지를 저장하는 문제면 더할 때 오버플로우가 생기지 않는지 주의하자
                        :10844 쉬운 계단 수 (f(n,i=1..9)를 더하는 과정에서 오버플로 발생, 더할 때마다 나머지 구하기)
            0~5%:
                ****기본적인 엣지 케이스
                    모든 부등호 확인
                        :7568 덩치 (두 가지 기준으로 정렬하면 =도 포함됨), 14889 스타트와 링크 
                    여러 개 비교하는 상황에서 1개인 경우, 0개인 경우
                        :1967 트리의 지름 (여러 자식 중 가장 큰 것 + 두 번째로 큰 것으로 노드 값 계산할때 자식이 하나인 경우 처리방법)
                    아무 것도 해당되지 않는 경우
                        :12865 평범한 배낭 (18% - 어떤 물건도 배낭에 넣을 수 없는 경우 음수값을 리턴하도록 base condition의 -INF값을 매우 작게 설정했어야 함)
                        :1541 잃어버린 괄호 (3% - 마이너스가 없고 플러스만 있는 경우)
                *나눗셈이 존재할 경우
                    어떻게 처리하라고 했는지 문제조건 확인
                        :10989 수 정렬하기 (산술평균을 소수 첫번째 자리에서 반올림하라고 함)
                *케이스 분류하고 케이스마다 해야하는 작업 안해준 경우
                    :코드포스 A and B and Compilation Errors (예외 케이스에서 출력에 '\n' 안붙임)
                *dp base condition 체크보다 dp[i][j] 참조를 먼저 한 경우
                    :12865 평범한 배낭 (dp 인덱스 범위를 벗어난 곳을 참조했는데 글로벌 배열이라 오류 안뜨고 프로그램 진행됨, base condition 먼저 체크하자)
            5~99%:
                *문제 조건 확인
                    :4179 불! (불이 여러 개일 수 있는데 하나로 가정함)
                *인덱스 통일 - 0~n-1 인덱스인지 1~n 인덱스인지 통일. 
                    특히 배열의 [i]에서 i가 0부터 시작해서 n-1에서 끝나는지 확인
                    문제에서 1로 시작하는 번호가 주어진 경우 주의
                    :14889 스타트와 링크 (59% - 배열 인덱스를 1234로 그려둬서 1234 사용)
                ***pruning 코드 없애보기 - 정답까지 가지치기하는지
                    웬만하면 그리디하게 가지치기하지 말고 컴퓨터에게 직접 시켜보기
                        :14889 스타트와 링크 (59% - 대칭적인 결과 0과 양수만 봄), 1068 트리 (78%) ?? 1912 연속합 (a[i] < 0 나오면 연속합 끝내기로 했는데 -3 5 나오면 잠깐의 손해 감수하고 더하느 게 유리)
                *for i = i to n 과 vector push_back 혼용
                    resize(n)
                        for i = 1 to n {vec[i] 대입} //push_back 하면 의도와 다르게 작동
                        or
                        for &elem : vec {elem 대입}
                    reserve(n), for i = 1 to n {vec.push_back} //vec[i] 불가
                    :1068 트리 (79% - resize(n)으로 채우고 for (i=1 to n) 안에서 push_back해서 n+1칸부터 쌓임)
                *변수 초기값이 모든 케이스 커버하나 확인 -> 초기값의 갱신이 안 되는 경우에도 초기값이 모든 케이스 커버하나? (특히 DP)
                    :1915 가장 큰 정사각형 (max_size 0으로 초기화했는데 DP 갱신을 1번 라인부터 해서, 0번 라인에서 최대 사이즈가 존재하는 경우에도 max_size 갱신 안하고 0으로 나오는 케이스 존재)

    제출시 런타임 에러가 뜨면
        배열에 할당된 크기를 넘어서 접근했을 때
            :입력 개수보다 배열을 적게 할당했을 때
                :8112 0과 1 - 2
        전역 배열의 크기가 메모리 제한을 초과할 때
        지역 배열의 크기가 스택 크기 제한을 넘어갈 때
        0으로 나눌 떄
        라이브러리에서 예외를 발생시켰을 때
        재귀 호출이 너무 깊어질 때
        이미 해제된 메모리를 또 참조할 때
        프로그램(main 함수)이 0이 아닌 수를 반환했을 때, 반환형이 void가 아닌 main이 아닌 함수에서 아무런 값을 반환하지 않았을 때

시간초과
    string 사용
        string을 함수에 인자로 넘기면 string 객체를 직접 복사하여 비용이 많이 소모된다.
        반면 char 배열로 넘기면 pass by reference라 복사비용 X

코드를 개선하자
    코드를 안전하게 만들기
        재귀 호출 시 잘못된 입력, 범위 벗어나는 케이스를 재귀함수 안에서 체크하기
            (밖에서 체크하면 동일한 로직을 호출할 때마다 여러 번 사용해야 함 (최초 재귀 호출부, 재귀함수 내 재귀호출 => 최소 2번))

        min, max구할 때 INF 할당
            양수 범위라고 -1 넣을 게 아니라 -987654321같은 극단적인 값 넣어야 출력 보고 이상한 점 발견함
            INT8_MAX는 127임에 주의

        여러 예외 케이스 있는 분기
            true되는 경우만 작성해 주고 나머지는 끝에서 return false로 한번에 처리하는 방식이 안전하고 보기도 명료함

        기본값으로부터 반드시 변해야 하는 값은 변했는지 assert()로 확인하기
            ex) MAX: default -INF 아님을 확인
            
        나누기 처리(평균, 분산, ...)
            곱해서 계산
            최솟값 구해야 하는 거면 가까운 정수 둘 다 해보기


    코드를 명료하게 만들기
        변경되지 않는 것에는 항상 const를 붙이자

        pass by reference로 전달하려면 함수 파라미터의 type뒤에 &을 붙이자
            => 변수를 전역변수처럼 쓸 수 있다!
            iterator에도 사용가능하다!

        2중 for문 탈출할 때는 2중 for문 앞뒤로 [&] { 내용 } ();으로 람다식 변환해서 return으로 빠져나가자
        
        간단한 구현 팁
            역순 정렬하기
                재귀 함수 사용하고 재귀 후 처리 (사실상 스택에 넣고 꺼내기)

        예외 처리 줄이는 방법
            정보를 좀 더 많이 담기
                dp차원 확장
                    :1149 RGB 거리, dp에 color 차원을 추가하니 훨씬 명료하고 같은 cost존재하는 예외 처리 필요없는 코드 만들 수 있었음
    
    코드를 간결하게 만들기
        함수 호출 시 밖에서 돌려봐야 하면, 가상의 arr[-1] = -INF를 추가해보자 (arr에 직접 추가가 아니라 함수에 예외로서 구현)
            :알고스팟 lis2 (main에서 lis2()호출할때 모든 원소 for문으로 해봐야 했는데, 가상의 원소 -INF로 시작하는 수열만 고려하게 할 수 있다)
        반복문보다 재귀함수를 쓰자 (특히 문자열)
            :1541 잃어버린 괄호 (부분 문자열을 재귀함수 파라미터로 넘기면 훨씬 간결한 코드를 짤 수 있다)
        붙어있는 문자열 받을 때는 받아서 split 구현하는 것보다 scanf로 받으면 %c, %d 등을 통해 하나씩 받을 수 있다.
            :1541 잃어버린 괄호

    코드를 빠르게 만들기
        반복해서 사용되고 함수 호출 비용이 함수의 내용보다 큰 함수는 inline 키워드를 사용하자

기억할 만한 사항
    수학
        나머지
            def. n % x = b <=> n = ax + b
            성질
                (a + m) % m = a % m
                (a + b) % m = (a % m + b % m) % m
                (a * b) % m = (a % m * b % m) % m
            음수의 나머지 연산
                c99표준: 제수, 피제수 모두 양수로 가정하고 몫과 나머지를 구한 다음, 몫은 직관대로, 나머지는 피제수의 부호를 따르면 된다.
                    (어떤 경우에도 a = bq + r 만족, 0에 대칭으로 연산한다고 생각하면 됨)
                    따라서 (a-1)%주기는 음수가 나올 수 있으므로 (a+주기-1)%주기 로 사용
                => 값 자체는 대칭적이나 평행이동 후 나누기 연산의 값이 달라질 수 있다. (정수 범위에서 대칭적인 연산 X)
                    http://agile.egloos.com/1666312
                python: 0 <= r < q 만족하도록 나눔
            노드에 나머지 저장하기
                허용되는 상황: linear 연산? (ax + by + c)
                    pf)
                        x, y => ax + by + c
                        x % m, y % m => a(x % m) + b(y % m) + c
                        todo: (ax + by + c)%m = a(x % m) + b(y % m) + c 증명
                            (ax + by + c)%m = ((ax) % m + (by) % m + c % m) % m
                            = ((a % m) * (x % m) % m + (b % m) * (y % m) % m + c % m) % m
                            (a, b, c < m 이면)
                            = (a * (x % m) % m + b * (y % m) % m + c % m) % m
                            = (a * (x % m) + b * (y % m) + c) % m
    C++
        2차원 배열의 작동원리 #
            메모리 주소는 어차피 1차원이라 arr[행][열] = arr + 행 * 열갯수 + 열 로 계산하는듯
            그러니까 함수에 n차원 배열 넘겨줄 때는 첫 인자는 비워도 되고 나머지는 채워야 하는 것
            (행 갯수는 몰라도 각 칸의 주소를 계산할 수 있지만, 열 갯수는 모르면 주소 계산 못하므로)
            ex) arr[][] = {1,2,3,4,5,6,7,8,9} 컴퓨터: ??
                arr[][3] = {1,2,3,4,5,6,7,8,9} 컴퓨터: 아하! 3마다 다음 행으로 보는군

        2차원 배열의 초기화
            memset: 사용법 간단, 0/-1/1로만 초기화 가능?
            fill: char 2차원 배열 초기화할 때 뭔가 문제가 있었다..? (4179불)
                fill(&arr[0][0], &arr[0][0]+MAX1*MAX2);
            안되면 그냥 2중for문써라

        항상 헷갈리는 compare
            sort의 인자로 쓰이는 bool compare (a, b) return predicate(a,b)
            앞의 원소 a, 뒤의 원소 b가 predicate(a, b)를 만족하도록 정렬함 (예: return a < b: 앞의 원소 a < 뒤의 원소 b를 만족하도록 정렬함)

        벡터의 활용
            선언
                vector initilize with size n: vector<type> vec(n)
                    벡터의 재할당 연산 시간소요를 막으려면 처음부터 reserve()를 이용해 capacity를 늘려둬라.
                = vector 선언 + vector resize()
                    resize (기본값으로 초기화된 원소 삽입(size변함)) != reserve (공간 예약(capacity 변함, size 변하지 않음), 메모리 공간 할당만 하고 컨테이너 추가하지 않아 push_back안하고 [index]로 사용 불가)
                벡터를 선언하는 5가지 방법 https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/
                특정 size의 벡터를 생성하는 방법 https://stackoverflow.com/questions/25108854/initializing-the-size-of-a-c-vector/25108894 
                전역 벡터 size n 선언
                    vector <type> vec;
                    int main() {
                        vec = vector<type>(n);
                    }
            입력
                vector input: for (auto &elem: vec) {cin >> elem}
            정렬
                vector sort with lamda: [](type a, type b){return a < b;}
            기타 기능
                vector make vecotr unique: unique(vec.begin(), vec.end()) => 중복된 원소 뒤로 보내버려 생긴 쓰레기값의 시작점 리턴
                                    erase(unique(vec.begin(), vec.end()) , vec.end());
            
        입출력
            문자열 다루어야 하면 string 이용
                int를 포함한 문자열 출력해야 하면 to_string(int n) 이용
                concatenating: 문자열끼리는 그냥 + 연산자 가능
                slicing: output = output.substr(k, output.length() - n); 앞 k, 뒤 n 글자 잘라내기 (대입해줘야 하는 거 보니 imutable 속성인듯)
                'cout << string변수'로 쉽게 출력 가능
            포맷팅
                char *str = (char *)malloc(sizeof(char) * 60);
                sprintf(str, "%.10f\n", climb(0, 0));
                cout << str;
                free(str);

        내장함수
            min: 3개 이상 인자 비교할땐 min({elem1, elem2, elem3}) 중괄호로 감싸기

문제풀이 방법론
    방법론
    문제유형: CSP? Optimization? Search? Regression?
        Regression 문제: 결과가 equivalent한 더 빠른 규칙 찾기
        step 1. 완전탐색하는 방법 생각 (정의역에서 원소 차례로 / DFS / BFS, ...)
        step 2. 관계성 찾기: 수학적 귀납법 (최소한의 정보만 체크, 중복된 정보 제거, )
            있으면? => 활용
                직접적인 관계 => 그리디
                점화식 => DP
                부분 구조 반복 => 분할 정복, DP
            없으면? => NP문제 (완전탐색, DFS, BFS)

    알고리즘
        완전탐색
            반복문구현
            재귀구현
                1. 그림그리기 (구조화) - 상향식/하향식 결정
                2. 목적을 명확히 - 함수의 인자와 return값 결정
                3. base condition 설정
                4. 작업 명확히 하기
            최대 크기 입력에서 답의 개수 계산, 제한 시간 내에 모두 생성할 수 있는가 확인
                yes => 완탐
                    답의 후보를 만드는 여러 개의 '선택'조각으로 나눔
                    조각 하나를 선택해 답의 일부를 구성하고 나머지는 재귀 호출로 완성
                    조각이 하나만 남을 경우/ 하나도 남지 않을 경우 base case이므로 조건에 부합하나 확인
                        tip: 중복 제거: '선택'할 때 순서를 강제 (한 답을 한 가지 방법으로밖에 생성할 수 없도록)
                no => 다른 방법론
            코드 기본 틀
                부분 해결 재귀함수(문제) {
                    base condition 확인 //모든 선택을 끝냈는지?
                        선택들이 조건 만족하는지 확인
                        최적화 문제면 최적 갱신 //optional
                    for 해당 단계의 선택들
                        선택 -> 적용
                        부분 해결 재귀함수(선택 적용한 부분문제)
                        선택 적용한 것 복구 //optional
                }
            유형
                경우의 수
                    순열 (next_permutation 사용가능)
                    조합 (이항 계수)
                    n개의 Y/N 질문 (비트마스킹 1차원 for문)
        DP
            문제풀이 순서
                하향식: 뒤를 보기
                    step1. 완전탐색
                        파라미터 설정: 최소에서 늘려가기
                            파라미터는 추상적인 형태로 생각하고 구현은 별개로 (ex: 인덱스 대신 수열 자체, 벡터 대신 가능한 수의 집합 등)
                            주어진 파라미터만으로 재귀적인 완전탐색 함수를 구현할 수 있을 때까지 늘리기
                        완전탐색 재귀적 함수 정의는 '특정 조건을 만족하는'이 아니라 '현재 탐색 상태를 표현하는'이 적절
                            O(1)만에 재귀적으로 모든 상태를 탐색하는 데 유리하다
                            조건 만족하는지 여부 따져주기
                                :9251 LCS (시작 문자가 같은 두 문자열이 아니라 그냥 두 문자열을 인자로 받으면 모든 경우 탐색을 max(lcs(a,b+1),lcs(a+1,b))만으로 가능)
                            완탐 함수 정의에 추가 파라미터가 붙어서 최초 호출시 모든 파라미터 옵션을 비교해야 하는 경우
                                모든 파라미터 호출
                                    함수 밖에서 모든 파라미터 옵션 호출할 때 에러가 생길 수 있는지 확인
                                        :1912 연속합 (isAccumulating = 1 인 옵션은 호출하면 아무 수도 안 더하는 경우 발생할 수 있고, 호출할 필요도 없었다)
                                기본값 패딩 (ex: a[-1] = 0)
                                    함수 자체에서 예외로서 구현
                                    직접 추가해주기
                                        인덱스 <= n, n-1 주의!
                    step2. 중복된 부분문제만 해결하도록 메모이제이션
                        최적 부분 구조 가지나 확인
                            최적 부분 구조면 파라미터가 결정되면 답이 결정됨?? //"조각 하나를 선택해 답의 일부를 구성하고 나머지는 재귀 호출로 완성"에서 '나머지 재귀 호출'부분을 DP테이블로 대체가능
                            최적 부분 구조가 아니면 파라미터를 추가하는 방식으로 가능
                                :알고스팟 Quantize
                                파라미터 추가로 경우의 수가 너무 많아지면 답의 형태를 강제하는 방식 고려
                상향식: 앞을 보기
                    상향식이 더 편할 때가 있다
                        :1912 연속합 (뒤를 보면 isAccumulating 정보가 필요하지만 앞을 보면 sum[end-1]값만 보면 됨)
                    step1. DP 설정하기 (목표를 고려해서 명료하게)
                        DP 테이블이 모든 케이스 커버하도록 해야 한다.
                        방법1 목표 = DP 테이블
                            DP에서 목표 도출은 쉬우나 DP 점화식 찾기가 어려울 수 있다
                        방법2 목표 != DP 테이블
                            점화식 찾기가 쉬워지나 DP 테이블과 정답과의 관계를 추가로 설정해야 한다
                                :1915 가장 큰 정사각형 (모든 DP 테이블 계산할때 max값 갱신한 것이 정답)
                    step2. 점화식 도출하기
                        easy
                            해당 DP로 오는 모든 케이스 고려하기
                                다른 케이스에 포함되는 케이스는 제외하기
                            계단 그림으로 생각
                                한 계단 아래, 두 계단 아래.. 모두 고려하기 (모든 케이스 커버)
                                계단을 내려가다 보면 특정 순간부터 모두 다른 케이스에 포함됨 (불필요한 경우 제외)
                        HARD
                            '전체가 최적이면 부분도 최적' 구조를 가질 때
                                하향식으로 겹치는 부분, 빠지는 부분 없이 완전히 케이스 분할
                                각 케이스는 부분 최적 구조를 포함해야 함.
                                tip - DP를 '남은 돈' 따위가 아니라 '사용가능한 돈'의 뉘앙스로 정의
                                    :knapsack problem (i번째 아이템을 산 경우(가능할 때)와 사지 않은 경우로 분할해 최댓값 구하기)
                            최적 부분 구조(optimal substructure)
                                각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻을 수 있는 경우
                                    :ex) 기존의 경로와 관계없이 남은 부분 문제를 최적으로 풀 수 있는 경우
                        안 떠오르면 그냥 써놓고 규칙 파악하는 방법도
                            이항계수, a*dp + b*dp_prev꼴
            구성요건
                초기조건
                점화식 (iterative consistency)
                    상향식
                    하향식
                        해당 DP로 오는 모든 케이스 커버하면 OK
                끝 (iterative consistency를 활용해 답 도출)
            최적화: 전체 DP 테이블 유지할 필요 없을 때 많다.
                갱신에 필요한 DP 값만 유지! (변수 혹은 배열 일부)
                    단, 공간은 절약하는 대신 이전 dp 갱신 비용 듦.
                    dp, dp_prev, dp_prev_prev: dp[i] = f(dp[i-1], dp[i-2])
                    dp[n], dp_prev[n] : 2차원 혹은 구간(라인)별로
                => 큐 사용하면 갱신비용도 필요없다?
                    큐 말고 dp[cur % 주기]처럼 % 이용하면 덮어쓰기로 갱신 비용도 필요없음
                갱신에 필요한 인덱스를 보고 순서를 잘 맞추면 이전 DP값 저장할 필요 없을때도 있다
                    cf) dp갱신 순서가 뒤섞이면 (화살표가 교점이 생기면) dp갱신에 이미 갱신된 dp 사용됨 => 이전 dp 저장 필요
                    : 1932 정수 삼각형 (갱신시 i, i-1만 보므로 오른쪽부터 갱신하면 dp_prev를 저장할 필요 없음)
        그리디
            증명
                탐욕적 선택 속성 (greedy choice property) : 각 단계에서 그리디하게 내리는 선택은 항상 최적해로 가는 길 중 하나다 (손해를 보지 않는다)
                    증명 할 것: 우리가 선택한 방법을 포함하는 최적해가 존재한다.
                        우리가 선택한 방법을 포함하지 않는 최적해 가정
                        적절히 조작해 우리가 선택한 방법을 포함하는 최적해로 변형할 수 있음을 보임
                최적 부분 구조 (optimal substructure) : 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있다 (대부분 자ㅕㅇ)

        그래프 탐색
            탐색!
                문제 형식화
                    초기상태, 액션, 전이모형, 골 테스트, 경로비용 
            그래프의 표현
                인접 행렬: 2차원 배열 - 메모리 사용 많음
                인접 리스트: 벡터 - 메모리 사용 적음
            DFS: 다음 자식을 탐색하기 전에 그전 자식의 모든 subgraph탐색
                재귀구현
                {type} dfs(int cur) {
                    visit[cur] = 1;
                    for i in adj[cur] {
                        if (visit[adj[cur][i]]) //base condition
                            continue;
                        dfs(adj[cur][i]);
                    }
                    visit[cur] = 0;
                }
                스택구현
            BFS
                템플릿
                    while q not empty
                        방문 (pop)
                        자식 생성
                        for 자식들에 대해
                            (생성 가능한 노드인가 테스트)
                            visited 테스트
                            골 테스트

                            visited 플래그
                            노드 처리
                            확장 (push)
                
                주의사항
                    goal test 순서가 답에 영향을 줄 수 있다 (부모를 확인해야 하는데 덮어씌우는 경우)
                        방문, 처리, test 순서를 일관되게! 방문->처리->테스트 or 방문->테스트->처리 (특히 goal test와 visit test는 같은 수준에서 수행해야)
                            :8112 0과 1 - 2 (goal,visit 테스트 같은 수준에서 안함)
                    visited는 상태 공간과 같은 차원
                        :1726 로봇 (visited를 map처럼 2차원으로 했는데 방향을 포함한 3차원이어야 함)
                BFS에 레벨을 추가하는 법
                    1. 레벨 기록
                        배열에, 혹은 상태노드에 레벨을 기록하고 자식들은 +1에서 확장
                        각 레벨을 순차적으로 펼치게 됨
                    2. 레벨 단위 수행
                        큐가 빌때까지 계속 반복하는 게 아니라 각 단위에서 큐 사이즈만큼 반복
                        단위가 상태 노드 단위가 아니라 레벨 단위로 반복하게 됨

기출 알고리즘
    큰 수의 곱셈 - 카라츠바 알고리즘 O(n^lg3)
        :알고스팟 FANMEETING