미완성 스켈레톤 코드 실행했는데 의도대로 작동 안하면
    입출력 문제
        입력받은 문자열의 문자 하나씩 수행하는 도중 한번 더 수행됨
            for (int i=0;str[i]!='\0';i++)에서 '\0' 대신 '\n' 사용함: 자구과제4

코드를 실행했는데 입력받고 아무것도 안하면
    우분투로 실행해 보기
        아무 것도 안뜨고 종료되면
            N을 입력받지 않음..
                :10989 수 정렬하기 3

코드를 실행하면 런타임 에러가 나오면
    아무것도 안했는데 run하자마자 '작동이 중지되었습니다' 나오면
        우분투로 실행해 보기
            Segmentation fault 나오면
                SegFault 나올 수 있는 곳 찾기
                case
                    fill:
                case
                    배열 선언 (배열을 너무 크게 잡은 경우): 4179 불 (1000*1000 3개)
            Floating point exception (core dumped) 나오면
                n을 입력받지 않아 생긴 에러
                    :

테스트 케이스에서 답이 원하는 대로 안 나오면
    제일 기본적인 테스트 케이스부터 수행
    제대로 나오면
        케이스 사이즈를 키워가며 수행
    이상한 점이 발견되면
        코드 읽어보기
            점검사항:
            배열 사이즈
            int overflow -> 중간연산에서 가능성있으므로 전부 long long으로
                :코포edu86 A
            코드 흐름 제어 (continue(해당반복중단) < break(반복문중단) < return (함수중단))
            반복 문제 (dfs) -> 시작, 끝, 반복 단위 명확히 설정
                :9663 N퀸(dfs종료조건 1작게설정)
        코드에 문제가 없는 것 같으면
            문제 정의 다시 읽어보기: 9663 N퀸(대각선 체크 x), 

테스트 케이스에서는 답이 나오는데 제출시 WA가 뜨면
    case
        0~5%:
            기본적인 엣지 케이스
                모든 부등호 확인
                    문제조건: < 여야 하는지 <= 여야 하는지
                    구현: <로 구현했는지 <= 로 구현했는지
                        :7568 덩치 (두 가지 기준으로 정렬하면 =도 포함됨)
            나눗셈이 존재할 경우
                어떻게 처리하라고 했는지 문제조건 확인
                    :10989 수 정렬하기 (산술평균을 소수 첫번째 자리에서 반올림하라고 함)


기억할 만한 사항
2차원 배열의 작동원리 #
    메모리 주소는 어차피 1차원이라 arr[행][열] = arr + 행 * 열갯수 + 열 로 계산하는듯
    그러니까 함수에 n차원 배열 넘겨줄 때는 첫 인자는 비워도 되고 나머지는 채워야 하는 것
    (행 갯수는 몰라도 각 칸의 주소를 계산할 수 있지만, 열 갯수는 모르면 주소 계산 못하므로)
    ex) arr[][] = {1,2,3,4,5,6,7,8,9} 컴퓨터: ??
        arr[][3] = {1,2,3,4,5,6,7,8,9} 컴퓨터: 아하! 3마다 다음 행으로 보는군

2차원 배열의 초기화
    memset: 사용법 간단, 0/-1/1로만 초기화 가능?
    fill: char 2차원 배열 초기화할 때 뭔가 문제가 있었다..? (4179불)
    안되면 그냥 2중for문써라

항상 헷갈리는 compare
    sort의 인자로 쓰이는 bool compare (a, b) return predicate(a,b)
    앞의 원소 a, 뒤의 원소 b가 predicate(a, b)를 만족하도록 정렬함 (예: return a < b: 앞의 원소 a < 뒤의 원소 b를 만족하도록 정렬함)

벡터의 활용
    vector initilize with size n: vector<type> vec(n)
    vector input: for (auto &elem: vec) {cin >> elem}
    vector sort with lamda: [](type a, type b){return a < b;}
    vector make vecotr unique: unique(vec.begin(), vec.end()) => 중복된 원소 뒤로 보내버려 생긴 쓰레기값의 시작점 리턴
                            erase(unique(vec.begin(), vec.end()) , vec.end());
